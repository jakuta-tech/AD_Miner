{
    "template": {
        "name": "The name displayed during AD Miner execution (Requesting : <name>)",
        "request": "The neo4j request executed. Don't forget to escape double quotes \" :) ",
        "output_type": "The output type stored in neo4j.all_request[request_key][\"result\"]. list, dict and Graph are supported.",
        "is_a_write_request": "please specify true here if your request writes to the neo4j database. It allows correct execution in specific parallels modes.",
        "scope_query": "USE ONLY IF YOU SPECIFIED 'SKIP PARAM1 LIMIT PARAM2' to parallelize your request. The scope query request should be a neo4j request that returns the total count of elements you then want to SKIP and LIMIT. Ask @snowpeacock if unsure.",
        "postProcessing": "A python function to call just after your request. You should also define it in the neo4j_class.py file.",
        "is_a_gds_request": "true if this request returns a gs path and has attributes `create_gds_graph`, `gds_request` and `drop_gds_graph`",
        "create_gds_graph": "neo4j request to create a neo4j GDS graph. Used only for gds requests",
        "gds_request": "cypher request to compute path with cost computation",
        "gds_scope_query": "scope query for the gds request",
        "reverse_path": "To specify only if you need to return inverted paths, used for specific gds requests",
        "drop_gds_graph": "cypher request to drop the neo4j GDS graph",
        "_comment": "You can use useless json entries to write comments about your request in this file.",
        "_comment_2": "The following variables should be used in the neo4j request and will be replaced by the python code : $properties$, $extract_date$, $password_renewal$, $recursive_level$, $inbound_control_edges$, $path_to_group_operators_props$.",
        "_comment_3": "The cache file of your neo4j request will be named after its name in this file. The 'filename' attribute is deprecated."
    },
    "check_if_GDS_installed" : {
        "name": "Checking if Graph Data Science neo4j plugin is installed",
        "request": "SHOW PROCEDURES YIELD name RETURN 'gds.graph.project' IN COLLECT(name) AND 'gds.shortestPath.dijkstra.stream' IN COLLECT(name) as gds_installed",
        "output_type": "dict",
        "postProcessing": "Neo4j.check_gds_plugin"
    },
    "delete_orphans" : {
        "name": "Delete orphan objects that have no labels",
        "request": "MATCH (n) WHERE labels(n) = [\"Base\"] OR labels(n) = [\"AZBase\"] OR labels(n) = [\"Base\", \"AZBase\"] DETACH DELETE n",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "preparation_request_nodes": {
        "name": "Clean AD Miner custom attributes",
        "request": "MATCH (n) REMOVE n.is_server,n.is_dc,n.is_da,n.is_dag,n.can_dcsync,n.path_candidate,n.ou_candidate,n.contains_da_dc,n.is_da_dc,n.ghost_computer,n.has_path_to_da,n.is_admin,n.is_group_operator,n.members_count,n.has_members,n.user_members_count,n.is_operator_member,n.is_group_account_operator,n.is_group_backup_operator,n.is_group_server_operator,n.is_group_print_operator,n.is_account_operator,n.is_backup_operator,n.is_server_operator,n.is_print_operator,n.gpolinks_count,n.has_links,n.dangerous_inbound, n.is_adminsdholder,n.is_dnsadmin,n.da_types,n.vulnerable_ou,n.can_abuse_adcs,n.dac,n.dac_types,n.is_adcs,n.target_kud,n.is_gag,n.is_msol,n.is_rbcd_target,n.is_dcg",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "delete_unresolved": {
        "name": "Delete objects for which SID could not resolved",
        "request": "MATCH (n) WHERE ((n.domain IS NULL AND NOT (n:Domain)) OR n.name IS NULL) AND n.tenantid IS NULL DETACH DELETE n",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "delete_ADLocalGroup": {
        "name": "Delete ADLocalGroup objects",
        "request": "MATCH (d:ADLocalGroup) DETACH DELETE d",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "check_relation_types": {
        "name": "Checking relation types",
        "request": "MATCH ()-[r]->() RETURN DISTINCT type(r) as relationType",
        "output_type": "dict",
        "postProcessing": "Neo4j.check_relation_type"
    },
    "set_upper_domain_name": {
        "name": "Set domain names to upper case when not the case",
        "request": "MATCH (g) where g.domain <> toUpper(g.domain) SET g.domain=toUpper(g.domain) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_domain_attributes_to_domains": {
        "name": "Set domain attributes to domain objects when not the case",
        "request": "MATCH (d:Domain) where d.domain IS NULL SET d.domain = toUpper(d.name)",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "check_if_all_domain_objects_exist": {
        "name": "Check for unexisting domain objects",
        "request": "MATCH (d:Domain) WITH DISTINCT d.domain AS domain WITH COLLECT(domain) AS domains MATCH (o) WHERE NOT o.domain IN domains RETURN count(o)",
        "output_type": "list",
        "is_a_write_request": "true",
        "postProcessing": "Neo4j.check_all_domain_objects_exist"
    },
    "check_if_all_group_objects_have_domain_attribute": {
        "name": "Check for Group objects without domain attribute",
        "request": "MATCH (g:Group) WHERE g.domain <> split(g.name, \"@\")[-1] SET g.domain=split(g.name, \"@\")[-1]",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "preparation_request_relations": {
        "name": "Clean AD Miner custom relations",
        "request": "MATCH (g:Group)-[r:CanExtractDCSecrets|CanLoadCode|CanLogOnLocallyOnDC]->(c:Computer) DELETE r ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_server": {
        "name": "Set is_server=TRUE to computers for which operatingsystem contains Server)",
        "request": "MATCH (c:Computer)  WHERE toUpper(c.operatingsystem) CONTAINS \"SERVER\" SET c.is_server=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_non_server": {
        "name": "Set is_server=FALSE to other computers )",
        "request": "MATCH (c:Computer) WHERE c.is_server IS NULL  SET c.is_server=FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_dc": {
        "name": "Set dc=TRUE to computers that are domain controllers)",
        "request": "MATCH (c:Computer)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-516\" OR g.objectid ENDS WITH \"-521\" SET c.is_dc=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_nondc": {
        "name": "Set dc=FALSE to computers that are not domain controllers)",
        "request": "MATCH (c:Computer) WHERE c.is_dc IS NULL SET c.is_dc=FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_dcg": {
        "name": "Set is_dcg=TRUE to domain controllers groups",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-516\" OR g.objectid ENDS WITH \"-521\" SET g.is_dcg=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_nondcg": {
        "name": "Set is_dcg=TRUE to domain controllers groups",
        "request": "MATCH (g:Group) WHERE g.is_dcg IS NULL SET g.is_dcg=FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_isacl_adcs": {
        "name": "Set isacl to TRUE for ADCS privilege escalation paths (ADCSESCxx)",
        "request": "MATCH (u)-[r]->(g) WHERE r.isacl IS NULL AND type(r) CONTAINS 'ADCSESC' SET r.isacl=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "onpremid_ompremsesecurityidentifier": {
        "name": "Setting onpremid in case of old collector",
        "request": "MATCH (a)  WHERE NOT a.onpremisesecurityidentifier IS NULL set a.onpremid=a.onpremisesecurityidentifier",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_can_extract_dc_secrets": {
        "name": "ADD CanExtractDCSecrets relation from BACKUP OPERATORS OR SERVER OPERATORS groups to DCs of same domain",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-551\" OR g.objectid ENDS WITH \"-549\" MATCH (c:Computer{is_dc:true}) WHERE g.domain = c.domain MERGE (g)-[:CanExtractDCSecrets]->(c) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_unconstrained_delegations": {
        "name": "ADD UnconstrainedDelegations relation from objects with KUD to the corresponding domain",
        "request": "MATCH (m{unconstraineddelegation:true,is_dc:false}) MATCH (d:Domain) WHERE m.domain = d.domain MERGE (m)-[:UnconstrainedDelegations]->(d) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_adminsdholder": {
        "name": "Set is_adminsdholder to Container with AdminSDHOLDER in name",
        "request": "MATCH (c:Container) WHERE c.name STARTS WITH \"ADMINSDHOLDER@\" SET c.is_adminsdholder=true ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_dnsadmin": {
        "name": "Set is_dnsadmin to Group with DNSAdmins in name",
        "request": "MATCH (g:Group) WHERE g.name STARTS WITH \"DNSADMINS@\" SET g.is_dnsadmin=true ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_can_load_code": {
        "name": "ADD CanLoadCode relation from PRINT OPERATORS groups to DCs of same domain",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-550\" MATCH (c:Computer{is_dc:true}) WHERE g.domain = c.domain MERGE (g)-[:CanLoadCode]->(c) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_can_logon_dc": {
        "name": "ADD CanLogOnLocallyOnDC relation from ACCOUNT OPERATORS groups to DCs of same domain",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-548\" MATCH (c:Computer{is_dc:true}) WHERE g.domain = c.domain MERGE (g)-[:CanLogOnLocallyOnDC]->(c) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_da": {
        "name": "Set da=TRUE to users that are domain admins or administrators or enterprise admin",
        "request": "MATCH (c:User)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" SET c.is_da=TRUE, c.da_types=[]",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_msol": {
        "name": "Set is_da=TRUE and is_msol=TRUE to accounts associated with Microsoft Online Services",
        "request": "MATCH (c:User) where c.name STARTS WITH 'MSOL_' SET c.is_da=TRUE, c.is_msol=true",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "For user accounts with names starting with MSOL_, these refer to accounts associated with Microsoft Online Services"
    },
    "set_da_types": {
        "name": "Set the da type (domain, enterprise, key or builtin)",
        "request": "MATCH (c:User)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" WITH c,g, CASE WHEN g.objectid ENDS WITH \"-512\" THEN \"Domain Admin\" WHEN g.objectid ENDS WITH \"-518\" THEN \"Schema Admin\" WHEN g.objectid ENDS WITH \"-519\" THEN \"Enterprise Admin\" WHEN g.objectid ENDS WITH \"-525\" THEN \"Protected Users\" WHEN g.objectid ENDS WITH \"-526\" THEN \"_ Key Admin\" WHEN g.objectid ENDS WITH \"-527\" THEN \"Enterprise Key Admin\" WHEN g.objectid ENDS WITH \"-544\" THEN \"Builtin Administrator\" ELSE null END AS da_type SET c.da_types = c.da_types + da_type",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "for unknown reasons checking the whole condition has to be checked twice or it doesn't work",
        "_comment2": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_dag": {
        "name": "Set da=TRUE to groups that are domain admins or administrators or enterprise admin",
        "request": "MATCH (c:Group)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" SET c.is_da=TRUE",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"

    },
    "set_dag_types": {
        "name": "Set the da type (domain, enterprise, key or builtin)",
        "request": "MATCH (c:Group)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" WITH c,g, CASE WHEN g.objectid ENDS WITH \"-512\" THEN \"Domain Admin\" WHEN g.objectid ENDS WITH \"-518\" THEN \"Schema Admin\" WHEN g.objectid ENDS WITH \"-519\" THEN \"Enterprise Admin\" WHEN g.objectid ENDS WITH \"-525\" THEN \"Protected Users\" WHEN g.objectid ENDS WITH \"-526\" THEN \"_ Key Admin\" WHEN g.objectid ENDS WITH \"-527\" THEN \"Enterprise Key Admin\" WHEN g.objectid ENDS WITH \"-544\" THEN \"Builtin Administrator\" ELSE null END AS da_type SET c.da_types = c.da_types + da_type",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "for unknown reasons checking the whole condition has to be checked twice or it doesn't work",
        "_comment2": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_dagg": {
        "name": "Set da=TRUE to groups that are domain admins or administrators or enterprise admin",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" SET g.is_da=TRUE",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"

    },
    "set_dagg_types": {
        "name": "Set the da type (domain, enterprise, key or builtin)",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" WITH g, CASE WHEN g.objectid ENDS WITH \"-512\" THEN \"Domain Admin\" WHEN g.objectid ENDS WITH \"-518\" THEN \"Schema Admin\" WHEN g.objectid ENDS WITH \"-519\" THEN \"Enterprise Admin\" WHEN g.objectid ENDS WITH \"-525\" THEN \"Protected Users\" WHEN g.objectid ENDS WITH \"-526\" THEN \"_ Key Admin\" WHEN g.objectid ENDS WITH \"-527\" THEN \"Enterprise Key Admin\" WHEN g.objectid ENDS WITH \"-544\" THEN \"Builtin Administrator\" ELSE null END AS da_type SET g.da_types = g.da_types + da_type",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "for unknown reasons checking the whole condition has to be checked twice or it doesn't work",
        "_comment2": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_daggg": {
        "name": "Set dag=TRUE to the exact domain admin group (end with 512)",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-512\"  SET g.is_dag=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_dac": {
        "name": "Set dac=TRUE to computers that are domain admins or administrators or enterprise admin and not DC computer",
        "request": "MATCH (c:Computer{is_dc:False})-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" SET c.is_dac=TRUE, c.dac_types=[]",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_dac_types": {
        "name": "Set the dac types (domain, enterprise, key or builtin)",
        "request": "MATCH (c:Computer)-[:MemberOf*1..3]->(g:Group) WHERE g.objectid ENDS WITH \"-512\" OR g.objectid ENDS WITH \"-518\" OR g.objectid ENDS WITH \"-519\" OR g.objectid ENDS WITH \"-525\" OR g.objectid ENDS WITH \"-526\" OR g.objectid ENDS WITH \"-527\" OR g.objectid ENDS WITH \"-544\" WITH c,g, CASE WHEN g.objectid ENDS WITH \"-512\" THEN \"Domain Admin\" WHEN g.objectid ENDS WITH \"-518\" THEN \"Schema Admin\" WHEN g.objectid ENDS WITH \"-519\" THEN \"Enterprise Admin\" WHEN g.objectid ENDS WITH \"-525\" THEN \"Protected Users\" WHEN g.objectid ENDS WITH \"-526\" THEN \"_ Key Admin\" WHEN g.objectid ENDS WITH \"-527\" THEN \"Enterprise Key Admin\" WHEN g.objectid ENDS WITH \"-544\" THEN \"Builtin Administrator\" ELSE null END AS da_type SET c.da_types = c.da_types + da_type",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "for unknown reasons checking the whole condition has to be checked twice or it doesn't work",
        "_comment2": "-512 for DA, -518 for Schema admin, -519 for Enterprise Admin, -525 for Protected Users, -526 for Key Admin, -527 for Entreprise Key Admin, -544 for Builtin Admin"
    },
    "set_nonda": {
        "name": "Set is_da=FALSE to all objects that do not have is_da=TRUE",
        "request": "MATCH (c) WHERE c.is_da IS NULL SET c.is_da=FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_nondag": {
        "name": "Set is_dag=FALSE to all objects that do not have is_da=TRUE",
        "request": "MATCH (g) WHERE g.is_dag IS NULL SET g.is_dag=FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "del_fake_dc_admins": {
        "name": "Delete AdminTo edges from non-DA to DC",
        "request": "MATCH (g{is_da:false})-[rr:AdminTo]->(c:Computer{is_dc:true}) DETACH DELETE rr ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_group_operator": {
        "name": "Set is_group_operator to Operator Groups (cf: ACCOUNT OPERATORS, SERVER OPERATORS, BACKUP OPERATORS, PRINT OPERATORS)",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH \"-551\" OR g.objectid ENDS WITH \"-549\" OR g.objectid ENDS WITH \"-548\" OR g.objectid ENDS WITH \"-550\" SET g.is_group_operator=True SET g.is_group_account_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN true END, g.is_group_backup_operator = CASE WHEN g.objectid ENDS WITH \"-551\" THEN true END, g.is_group_server_operator = CASE WHEN g.objectid ENDS WITH \"-549\" THEN true END, g.is_group_print_operator = CASE WHEN g.objectid ENDS WITH \"-550\" THEN true END ",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "BACKUP OPERATORS ENDS WITH = S-1-5-32-551 | ACCOUNT OPERATORS ENDS WITH =  S-1-5-32-548",
        "_comment_2": "SERVER OPERATORS ENDS WITH = S-1-5-32-549 | PRINT OPERATORS ENDS WITH   = S-1-5-32-550"
    },
    "set_is_operator_member": {
        "name": "Set is_operator_member to objects member of Operator Groups (cf: ACCOUNT OPERATORS, SERVER OPERATORS, BACKUP OPERATORS, PRINT OPERATORS)",
        "request": "MATCH (o:User)-[r:MemberOf*1..5]->(g:Group{is_group_operator:True}) WHERE o.is_da=false OR o.domain <> g.domain SET o.is_operator_member=true SET o.is_account_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN true ELSE o.is_account_operator END, o.is_type_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN \"ACCOUNT OPERATOR\" ELSE o.is_type_operator END, o.is_backup_operator = CASE WHEN g.objectid ENDS WITH \"-551\" THEN true ELSE o.is_backup_operator END, o.is_type_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN \"BACKUP OPERATOR\" ELSE o.is_type_operator END, o.is_server_operator = CASE WHEN g.objectid ENDS WITH \"-549\" THEN true ELSE o.is_server_operator END, o.is_type_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN \"SERVER OPERATOR\" ELSE o.is_type_operator END, o.is_print_operator = CASE WHEN g.objectid ENDS WITH \"-550\" THEN true ELSE o.is_print_operator END, o.is_type_operator = CASE WHEN g.objectid ENDS WITH \"-548\" THEN \"PRINT OPERATOR\" ELSE o.is_type_operator END ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_dcsync1": {
        "name": "Set dcsync=TRUE to nodes that can DCSync (GetChanges/GetChangesAll)",
        "request": "MATCH (n1) WITH n1 ORDER BY n1.name SKIP PARAM1 LIMIT PARAM2 MATCH p=allShortestPaths((n1)-[:MemberOf|GetChanges*1..5]->(u:Domain)) WHERE n1 <> u WITH n1 MATCH p2=(n1)-[:MemberOf|GetChangesAll*1..5]->(u:Domain) WHERE n1 <> u AND NOT n1.name IS NULL AND (((n1.is_da IS NULL OR n1.is_da=FALSE) AND (n1.is_dc IS NULL OR n1.is_dc=FALSE)) OR (NOT u.domain CONTAINS '.' + n1.domain AND n1.domain <> u.domain)) SET n1.can_dcsync=TRUE RETURN DISTINCT p2 as p",
        "output_type": "Graph",
        "scope_query": "MATCH (n1) return count(n1)",
        "is_a_write_request": "true"
    },
    "set_dcsync2": {
        "name": "Set dcsync=TRUE to nodes that can DCSync (GenericAll/AllExtendedRights)",
        "request": "MATCH (n2) WITH n2 ORDER BY n2.name SKIP PARAM1 LIMIT PARAM2 MATCH p3=allShortestPaths((n2)-[:MemberOf|GenericAll|AllExtendedRights*1..5]->(u:Domain)) WHERE n2 <> u AND NOT n2.name IS NULL AND (((n2.is_da IS NULL OR n2.is_da=FALSE) AND (n2.is_dc IS NULL OR n2.is_dc=FALSE)) OR (NOT u.domain CONTAINS '.' + n2.domain AND n2.domain <> u.domain)) SET n2.can_dcsync=TRUE RETURN DISTINCT p3 as p",
        "output_type": "Graph",
        "scope_query": "MATCH (n1) return count(n1)",
        "is_a_write_request": "true"
    },
    "dcsync_list": {
        "name": "Get list of objects that can DCsync (and should probably not be to)",
        "request": "MATCH (n{can_dcsync:true}) RETURN n.domain as domain, n.name as name",
        "output_type": "dict"
    },
    "set_ou_candidate": {
        "name": "Set ou_candidate=TRUE to candidates eligible to shortestou to DA",
        "request": "MATCH (m) WHERE NOT m.name IS NULL AND ((m:Computer AND (m.is_dc=false OR m.is_dc IS NULL)) OR (m:User AND (m.is_da=false OR m.is_da IS NULL))) SET m.ou_candidate=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_containsda": {
        "name": "Set contains_da_dc=TRUE to all objects that contains a domain administrator",
        "request": "MATCH p=(o:OU)-[r:Contains*1..]->(x{is_da:true}) SET o.contains_da_dc=true RETURN p",
        "output_type": "Graph",
        "is_a_write_request": "true"
    },
    "set_containsdc": {
        "name": "Set contains_da_dc=TRUE to all objects that contains a domain controller",
        "request": "MATCH p=(o:OU)-[r:Contains*1..]->(x{is_dc:true}) SET o.contains_da_dc=true RETURN p",
        "output_type": "Graph",
        "is_a_write_request": "true"
    },
    "set_is_da_dc": {
        "name": "Set is_da_dc=TRUE to all objects that are domain controller or domain admins",
        "request": "MATCH (u) WHERE (u.is_da=true OR u.is_dc=true) SET u.is_da_dc=true",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_not_da_dc": {
        "name": "Set is_da_dc=FALSE to objects without is_da_dc = TRUE",
        "request": "MATCH (o:Base) WHERE o.is_da_dc IS NULL SET o.is_da_dc = FALSE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_path_candidate": {
        "name": "Set path_candidate=TRUE to candidates eligible to shortestPath to DA",
        "request": "MATCH (o{is_da_dc:false}) WHERE NOT o:Domain AND ((o.enabled=True AND o:User) OR NOT o:User) AND (NOT o.is_adcs OR o.is_adcs is null) SET o.path_candidate=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_groups_members_count": {
        "name": "Set members_count to groups counting users (recursivity = 5)",
        "request": "MATCH  (g:Group) WITH g ORDER BY g.name SKIP PARAM1 LIMIT PARAM2 MATCH (u:User)-[:MemberOf*1..5]->(g) WHERE NOT u.name IS NULL AND NOT g.name IS NULL WITH g AS g1, count(u) AS memberscount SET g1.members_count=memberscount",
        "output_type": "list",
        "scope_query": "MATCH (g:Group) RETURN count(g)",
        "is_a_write_request": "true",
        "_comment": "Recursivity = 5 seems the good match for ratio results/time when searching MemberOf*1..X when using our servers (else 3)"
    },
    "set_groups_members_count_computers": {
        "name": "Set members_count to groups counting computers (recursivity = 5)",
        "request": "MATCH (g:Group) WITH g ORDER BY g.name SKIP PARAM1 LIMIT PARAM2 MATCH (u:Computer)-[:MemberOf*1..5]->(g) WHERE NOT u.name IS NULL AND NOT g.name IS NULL WITH g AS g1, count(u) AS memberscount SET g1.members_count= COALESCE(g1.members_count, 0) + memberscount",
        "output_type": "list",
        "scope_query": "MATCH (g:Group) RETURN count(g)",
        "is_a_write_request": "true",
        "_comment": "Recursivity = 5 seems the good match for ratio results/time when searching MemberOf*1..X when using our servers (else 3)"
    },
    "set_groups_has_members": {
        "name": "Set has_member=True to groups with member, else false ",
        "request": "MATCH (g:Group) SET g.has_members=(CASE WHEN g.members_count>0 THEN TRUE ELSE FALSE END) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_gpo_links_count": {
        "name": "Set the count of links/object where the GPO is applied",
        "request": "MATCH p=(g:GPO)-[:GPLink]->(o) WITH g.name as gponame, count(p) AS gpolinkscount MATCH (g1:GPO) WHERE g1.name=gponame AND gpolinkscount IS NOT NULL SET g1.gpolinks_count=gpolinkscount ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_gpos_has_links": {
        "name": "Set has_links=True to GPOs with links, else false ",
        "request": "MATCH (g:GPO) SET g.has_links=(CASE WHEN g.gpolinks_count>0 THEN TRUE ELSE FALSE END) ",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_is_adcs": {
        "name": "Set is_adcs to ADCS servers",
        "request": "MATCH (g:Group) WHERE g.objectid ENDS WITH '-517' MATCH (c:Computer)-[r:MemberOf*1..4]->(g) SET c.is_adcs=TRUE RETURN c.domain AS domain, c.name AS name", 
        "output_type": "dict",
        "is_a_write_request": "true"
    },
    "set_groups_direct_admin": {
        "name": "Set groups which are direct admins of computers",
        "request": "MATCH (g:Group)-[r:AdminTo]->(c:Computer) SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true",
        "_comment": "This block of requests aims at optimizing the path requests by tagging interesting nodes"
    },
    "set_groups_indirect_admin_1": {
        "name": "1 - Set groups which are indirect admins of computers, ie. admins of admin groups (see precedent request)",
        "request": "MATCH (g:Group)-[r:MemberOf]->(gg:Group{is_admin:true}) SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_groups_indirect_admin_2": {
        "name": "2 - Set groups which are indirect admins of computers, ie. admins of admin groups (see precedent request)",
        "request": "MATCH (g:Group)-[r:MemberOf]->(gg:Group{is_admin:true}) WHERE g.is_admin IS NULL SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_groups_indirect_admin_3": {
        "name": "3 - Set groups which are indirect admins of computers, ie. admins of admin groups (see precedent request)",
        "request": "MATCH (g:Group)-[r:MemberOf]->(gg:Group{is_admin:true}) WHERE g.is_admin IS NULL SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_groups_indirect_admin_4": {
        "name": "4 - Set groups which are indirect admins of computers, ie. admins of admin groups (see precedent request)",
        "request": "MATCH (g:Group)-[r:MemberOf]->(gg:Group{is_admin:true}) WHERE g.is_admin IS NULL SET g.is_admin=true RETURN DISTINCT g",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_target_kud": {
        "name":"Set target_kud attribute on nodes that are configured for KUD",
        "request": "MATCH (o{unconstraineddelegation:true}) WHERE ((o:User AND o.enabled=true) OR (o:Computer AND o.is_dc=false)) SET o.target_kud=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_az_privileged": {
        "name": "Find all Azure objects that are privileged and set is_priv is true",
        "request": "MATCH (n:AZBase) WHERE 'admin_tier_0' IN split(n.system_tags, ' ') AND n.name =~ '(?i)Global Administrator.*|User Administrator.*|Cloud Application Administrator.*|Authentication Policy Administrator.*|Exchange Administrator.*|Helpdesk Administrator.*|Privileged Authentication Administrator.*'  SET n.is_priv=true",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_az_not_privileged": {
        "name": "Find all Azure objects that are not privileged and set is_priv is false",
        "request": "MATCH (n:AZBase) WHERE n.is_priv IS NULL SET n.is_priv=false",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "azure_set_apps_name": {
        "name": "Set Azure applications names",
        "request": "MATCH (a:AZApp) WHERE a.name IS NULL AND a.displayname IS NOT NULL SET a.name = a.displayname",
        "output_type": "List",
        "is_a_write_request": "true"
    },
    "nb_domain_collected": {
        "name": "Count number of domains collected",
        "request": "MATCH (m:Domain)-[r]->() RETURN distinct(COALESCE(m.domain, m.name))",
        "output_type": "list"
    },
    "get_count_of_member_admin_group": {
        "name": "Count number of users in group",
        "request": "MATCH (u:User{enabled:true})-[r:MemberOf]->(gg:Group{is_admin:true}) WHERE NOT u.name IS NULL and NOT gg.name IS NULL WITH count(u) as count, gg as g MATCH (g) SET g.user_members_count=count",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "get_users_linked_admin_group": {
        "name": "Returns all users member of an admin group",
        "request": "MATCH (u:User{enabled:true})-[r:MemberOf]->(gg:Group{is_admin:true}) WHERE NOT u.name IS NULL and NOT gg.name IS NULL SET u.is_admin=true RETURN u, gg, ID(u) as idu, ID(gg) as idg",
        "output_type": "dict",
        "is_a_write_request": "true"
    },
    "get_groups_linked_admin_group": {
        "name": "Returns all groups member of an admin group",
        "request": "MATCH (g:Group)-[r:MemberOf]->(gg:Group{is_admin:true}) WHERE NOT g.name IS NULL and NOT gg.name IS NULL RETURN g, gg, ID(g) as idg, ID(gg) as idgg",
        "output_type": "dict"
    },
    "get_computers_linked_admin_group": {
        "name": "Returns all computers administrated by an admin group",
        "request": "MATCH (g:Group{is_admin:true})-[r:AdminTo]->(c:Computer) WHERE NOT c.name IS NULL and NOT g.name IS NULL RETURN g, c, ID(g) as idg, ID(c) as idc",
        "output_type": "dict"
    },
    "get_users_direct_admin": {
        "name": "Return direct admin users",
        "request": "MATCH (g:User{enabled:true})-[r:AdminTo]->(c:Computer) WHERE NOT g.name IS NULL and NOT c.name IS NULL SET g.is_admin=True RETURN g, c, ID(g) as idg, ID(c) as idc",
        "output_type": "dict",
        "is_a_write_request": "true"
    },
    "set_ghost_computer": {
        "name": "Set ghost_computer=TRUE to computers that did not login for more than 90 days",
        "request": "MATCH (n:Computer) WHERE toInteger(($extract_date$ - n.lastlogontimestamp)/86400)>$password_renewal$ SET   n.ghost_computer=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "set_default_exploitability_rating" : {
        "name": "Set default exploitability rating (r.cost=100) to all relations",
        "request": "MATCH ()-[r]->() SET r.cost=100",
        "output_type": "list"
    },
    "check_unknown_relations" : {
        "name": "Checking for unknown relations",
        "request": "MATCH ()-[r]->() RETURN DISTINCT type(r) as relationType",
        "output_type": "list",
        "postProcessing": "Neo4j.check_unkown_relations"
    },
    "domains": {
        "name": "List of domains",
        "request": "MATCH (m:Domain) RETURN DISTINCT(m.name) AS domain ORDER BY m.name",
        "output_type": "list"
    },
    "nb_domain_controllers": {
        "name": "Number of domain controllers",
        "request": "MATCH (c1:Computer{is_dc:TRUE}) RETURN DISTINCT(c1.domain) AS domain, c1.name AS name, COALESCE(c1.operatingsystem, 'Unknown') AS os, COALESCE(c1.ghost_computer, False) AS ghost, toInteger(($extract_date$ - c1.lastlogontimestamp)/86400) as lastLogon",
        "output_type": "dict"
    },
    "domain_OUs": {
        "name": "Domain Organisational Units",
        "request": "MATCH (o:OU)-[:Contains]->(c) RETURN o.name AS OU, c.name AS name",
        "output_type": "dict"
    },
    "users_shadow_credentials": {
        "name": "Non privileged users that can impersonate privileged users",
        "request": "MATCH (u:User{enabled:true,is_da:false}) WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 MATCH p=allShortestPaths((u)-[r:MemberOf|AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl*1..3]->(m:User{is_da:true,enabled:true})) RETURN p ",
        "scope_query": "MATCH (u:User{is_da:false, enabled:true}) return count(u)",
        "output_type": "Graph"
    },
    "users_shadow_credentials_to_non_admins": {
        "name": "Non privileged users that can be impersonated by non privileged users",
        "is_a_gds_request": "true",
        "request": "CALL {MATCH (s:User{enabled:true, is_da:false}) RETURN s UNION ALL MATCH (s:Group{is_dag:false,is_da:false}) RETURN s} WITH s ORDER BY s.name SKIP PARAM1 LIMIT PARAM2 MATCH p=shortestPath((s)-[r:AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl*1..3]->(t:User{enabled:true})) WHERE s <> t AND s.is_group_account_operator IS NULL RETURN p",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_users_shadow_credentials_to_non_admins', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "gds_request": "MATCH (target:User{enabled:true}) CALL gds.allShortestPaths.dijkstra.stream('graph_users_shadow_credentials_to_non_admins', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE starting_node <> target AND starting_node.is_group_account_operator IS NULL AND starting_node.is_account_operator IS NULL AND ((starting_node:User AND starting_node.enabled AND NOT starting_node.is_da) OR (starting_node:Group AND NOT starting_node.is_dag AND NOT starting_node.is_da)) RETURN path as p",
        "drop_gds_graph": "CALL gds.graph.drop('graph_users_shadow_credentials_to_non_admins', false) YIELD graphName",
        "scope_query": "CALL {MATCH (s:User{enabled:true, is_da:false}) RETURN s UNION ALL MATCH (s:Group{is_dag:false,is_da:false}) RETURN s} WITH s ORDER BY s.name RETURN count(s)",
        "output_type": "Graph",
        "reverse_path": true
    },
    "nb_enabled_accounts": {
        "name": "Number of domain accounts enabled",
        "request": "MATCH p=(u:User{enabled:true} ) RETURN DISTINCT(u.domain) AS domain, u.name AS name, toInteger(($extract_date$ - u.lastlogontimestamp)/86400) AS logon ORDER BY u.domain",
        "output_type": "dict"
    },
    "nb_disabled_accounts": {
        "name": "Number of domain accounts disabled",
        "request": "MATCH p=(u:User{enabled:false} ) RETURN DISTINCT(u.domain) AS domain, u.name AS name, toInteger(($extract_date$ - u.lastlogontimestamp)/86400) AS logon ORDER BY u.domain",
        "output_type": "dict"
    },
    "nb_groups": {
        "name": "Number of groups",
        "request": "MATCH p=(g:Group) WHERE NOT g.name IS NULL AND NOT g.domain IS NULL RETURN DISTINCT(g.domain) AS domain, g.name AS name, g.is_da AS da ORDER BY g.domain",
        "output_type": "dict"
    },
    "nb_computers": {
        "name": "Number of computers",
        "request": "MATCH (c:Computer) WHERE NOT c.name IS NULL RETURN DISTINCT(c.domain) AS domain, c.name AS name, c.operatingsystem AS os, c.ghost_computer AS ghost ORDER BY c.domain",
        "output_type": "dict"
    },
    "computers_not_connected_since": {
        "name": "Computers not connected since",
        "request": "MATCH (c:Computer) WHERE NOT c.lastlogontimestamp IS NULL AND c.name IS NOT NULL RETURN c.name AS name, toInteger(($extract_date$ - c.lastlogontimestamp)/86400) as days, toInteger(($extract_date$ - c.pwdlastset)/86400) as pwdlastset, c.enabled as enabled ORDER BY days DESC ",
        "output_type": "dict"
    },
    "nb_domain_admins": {
        "name": "Number of domain admin accounts",
        "request": "MATCH (n{enabled:true}) WHERE n.is_msol IS NULL AND n.is_da = TRUE RETURN n.domain AS domain, n.name AS name, n.da_types AS `admin type`, n.admincount AS `admincount`",
        "output_type": "dict"
    },
    "os": {
        "name": "Number of OS",
        "request": "MATCH (c:Computer{enabled:true}) WHERE  NOT c.enabled IS NULL AND NOT c.operatingsystem IS NULL RETURN DISTINCT(c.operatingsystem) AS os, toInteger(($extract_date$ - c.lastlogontimestamp)/86400) as lastLogon, c.name AS name, c.domain AS domain ORDER BY c.operatingsystem",
        "output_type": "dict"
    },
    "krb_pwd_last_change": {
        "name": "Kerberos password last change in days",
        "request": "MATCH(u:User) WHERE u.name STARTS WITH \"KRBTGT@\" RETURN u.domain as domain, u.name as name, toInteger(($extract_date$ - u.pwdlastset)/86400) as pass_last_change, toInteger(($extract_date$ - u.whencreated)/86400) AS accountCreationDate",
        "output_type": "dict"
    },
    "nb_kerberoastable_accounts": {
        "name": "Number of Kerberoastable accounts",
        "request": "MATCH (u:User{hasspn:true,enabled:true}) WHERE u.gmsa IS NULL AND u.name IS NOT NULL RETURN u.domain AS domain, u.name AS name, toInteger(($extract_date$ - u.pwdlastset)/86400) AS pass_last_change, u.is_da AS is_Domain_Admin, u.serviceprincipalnames AS SPN, toInteger(($extract_date$ - u.whencreated)/86400) AS accountCreationDate ORDER BY pass_last_change DESC",
        "output_type": "dict"
    },
    "nb_as-rep_roastable_accounts": {
        "name": "Number of AS-REP Roastable accounts",
        "request": "MATCH (u:User{enabled:true,dontreqpreauth: true}) RETURN u.domain AS domain,u.name AS name, u.is_da AS is_Domain_Admin",
        "output_type": "dict"
    },
    "nb_computer_unconstrained_delegations": {
        "name": "Number of machines with unconstrained delegations",
        "request": "MATCH (c2:Computer{unconstraineddelegation:true,is_dc:FALSE}) RETURN DISTINCT(c2.domain) AS domain,c2.name AS name",
        "output_type": "dict"
    },
    "nb_users_unconstrained_delegations": {
        "name": "Number of users with unconstrained delegations",
        "request": "MATCH (c2:User{enabled:true,unconstraineddelegation:true,is_da:FALSE}) RETURN DISTINCT(c2.domain) AS domain,c2.name AS name",
        "output_type": "dict"
    },
    "users_constrained_delegations": {
        "name": "Number of users with constrained delegations",
        "request": "MATCH (u:User)-[:AllowedToDelegate]->(c:Computer) WHERE u.name IS NOT NULL AND c.name IS NOT NULL RETURN u.name AS name, c.name AS computer,c.is_dc as to_DC ORDER BY name",
        "output_type": "dict"
    },
    "dormant_accounts": {
        "name": "Dormant accounts",
        "request": "MATCH (n:User{enabled:true}) WHERE toInteger(($extract_date$ - n.lastlogontimestamp)/86400)>$password_renewal$ RETURN n.domain as domain, n.name as name,toInteger(($extract_date$ - n.lastlogontimestamp)/86400) AS days, toInteger(($extract_date$ - n.whencreated)/86400) AS accountCreationDate ORDER BY days DESC",
        "output_type": "dict"
    },
    "password_last_change": {
        "name": "Password last change in days",
        "request": "MATCH (c:User {enabled:TRUE}) RETURN DISTINCT(c.name) AS user,toInteger(($extract_date$ - c.pwdlastset )/ 86400) AS days, toInteger(($extract_date$ - c.whencreated)/86400) AS accountCreationDate ORDER BY days DESC",
        "output_type": "dict"
    },
    "nb_user_password_cleartext": {
        "name": "Number of accounts where password cleartext password is populated",
        "request": "MATCH (u:User) WHERE NOT u.userpassword IS null RETURN u.name AS user,\"[redacted for security purposes]\" AS password, u.is_da as `is Domain Admin`",
        "output_type": "dict"
    },
    "get_users_password_not_required": {
        "name": "Number of accounts where password is not required",
        "request": "MATCH (u:User{enabled:true,passwordnotreqd:true}) RETURN DISTINCT (u.domain) as domain, (u.name) AS user,toInteger(($extract_date$ - u.pwdlastset )/ 86400) AS pwdlastset,toInteger(($extract_date$ - u.lastlogontimestamp)/86400) AS lastlogon",
        "output_type": "dict"
    },
    "objects_admincount": {
        "name": "N objects have AdminSDHolder",
        "request": "MATCH (n{enabled:True, admincount:True}) RETURN n.domain as domain, labels(n) as type, n.name as name ",
        "output_type": "dict",
        "_comment": "FIXME: the UNION is messing up the AS and breaks the grid 'UNION MATCH (n{admincount:true}) RETURN n.domain as domain, labels(n) as type, n.name as name',"
    },
    "user_password_never_expires": {
        "name": "Password never expired",
        "request": "MATCH (u:User{enabled:true})WHERE u.pwdneverexpires = true RETURN DISTINCT(u.domain) AS domain, u.name AS name, toInteger(($extract_date$ - u.lastlogontimestamp)/86400) AS LastLogin, toInteger(($extract_date$ - u.pwdlastset )/ 86400) AS LastPasswChange,toInteger(($extract_date$ - u.whencreated)/86400) AS accountCreationDate",
        "output_type": "dict"
    },
    "computers_members_high_privilege": {
        "name": "High privilege group computer member",
        "request": "MATCH(c:Computer{is_dc:false})-[r:MemberOf*1..4]->(g:Group{is_da:true}) WHERE NOT c.name IS NULL RETURN distinct(c.name) AS computer, g.name AS group, g.domain AS domain",
        "output_type": "dict"
    },
    "objects_to_domain_admin": {
        "name": "Objects with path to DA",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_objects_to_domain_admin', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:$properties$]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_objects_to_domain_admin', false) YIELD graphName",
        "request": "MATCH (m{path_candidate:true}) WHERE NOT m.name IS NULL WITH m ORDER BY ID(m) SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((m)-[r:$properties$*1..$recursive_level$]->(g:Group{is_dag:true})) WHERE m<>g SET m.has_path_to_da=true RETURN DISTINCT(p) as p",
        "gds_request" : "MATCH (target:Group {is_dag: true}) CALL gds.allShortestPaths.dijkstra.stream('graph_objects_to_domain_admin', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE starting_node.path_candidate = TRUE SET starting_node.has_path_to_da=true RETURN path as p",
        "output_type": "Graph",
        "scope_query": "MATCH (m{path_candidate:true}) WHERE NOT m.name IS NULL RETURN count(m)",
        "reverse_path": true,
        "is_a_write_request": "true"
    },
    "objects_to_adcs": {
        "name": "Objects with path to ADCS servers",
        "request": "MATCH (o{path_candidate:true}) WHERE NOT o.name IS NULL WITH o ORDER BY o.name SKIP PARAM1 LIMIT PARAM2 MATCH p=(o)-[rrr:MemberOf*0..4]->()-[rr:AdminTo]->(c{is_adcs:true}) RETURN DISTINCT(p) as p",
        "output_type": "Graph",
        "scope_query": "MATCH (m{path_candidate:true}) WHERE NOT m.name IS NULL RETURN count(m)"
    },
    "users_admin_on_computers": {
        "name": "Users admin on machines",
        "request": "MATCH p=(n:User{enabled:true})-[r:MemberOf|AdminTo*1..4]->(m:Computer) WHERE n:User AND n.enabled=true RETURN distinct(n.name) AS user,m.name AS computer,m.has_path_to_da AS has_path_to_da, ID(n) as user_id",
        "output_type": "dict"
    },
    "users_admin_on_servers_1": {
        "name": "Users admin on servers n\u00b01",
        "request": "MATCH (n:User{enabled:true,is_da:false}) WHERE NOT n.name IS NULL WITH n ORDER BY ID(n) SKIP PARAM1 LIMIT PARAM2 MATCH p=(n)-[r:MemberOf*1..4]->(g:Group)-[r1:$properties$]->(u:Computer) WITH LENGTH(p) as pathLength, p, n, u WHERE NONE (x in NODES(p)[1..(pathLength-1)] WHERE x.objectid = u.objectid) AND NOT n.objectid = u.objectid RETURN n.name AS user, u.name AS computer, u.has_path_to_da as has_path_to_da",
        "scope_query": "MATCH (n:User{enabled:true,is_da:false}) WHERE NOT n.name IS NULL RETURN count(n)",
        "output_type": "dict"
    },
    "users_admin_on_servers_2": {
        "name": "Users admin on servers n\u00b02",
        "request": "MATCH (n:User{enabled:true,is_da:false}) WHERE NOT n.name IS NULL WITH n ORDER BY ID(n) SKIP PARAM1 LIMIT PARAM2 MATCH p=(n)-[r1:$properties$]->(u:Computer) WITH LENGTH(p) as pathLength, p, n, u WHERE NONE (x in NODES(p)[1..(pathLength-1)] WHERE x.objectid = u.objectid) AND NOT n.objectid = u.objectid RETURN n.name AS user, u.name AS computer, u.has_path_to_da as has_path_to_da",
        "scope_query": "MATCH (n:User{enabled:true,is_da:false}) WHERE NOT n.name IS NULL RETURN count(n)",
        "output_type": "dict"
    },
    "computers_admin_on_computers": {
        "name": "Number of computers admin of computers",
        "request": "CALL{MATCH (c1:Computer)-[r1:AdminTo]->(c2:Computer) WHERE c1.name IS NOT NULL AND c2.name IS NOT NULL AND c1 <> c2 RETURN c1.name AS source_computer, c2.name AS target_computer, c2.has_path_to_da AS has_path_to_da UNION ALL MATCH (c1:Computer)-[r2:MemberOf*1..4]->(g:Group)-[r3:AdminTo]->(c2:Computer) WHERE c1.name IS NOT NULL AND c2.name IS NOT NULL AND c1 <> c2 RETURN c1.name AS source_computer, c2.name AS target_computer, c2.has_path_to_da AS has_path_to_da}  RETURN distinct(source_computer), target_computer, has_path_to_da",
        "output_type": "dict"
    },
    "domain_map_trust": {
        "name": "Domain map trust",
        "request": "MATCH p=shortestpath((d:Domain)-[:TrustedBy]->(m:Domain)) WHERE d<>m RETURN DISTINCT(p)",
        "output_type": "Graph"
    },
    "kud": {
        "name": "Shortest paths to objects configured for KUD",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_kud', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:$properties$]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_kud', false) YIELD graphName",
        "request": "MATCH (n) WHERE (n:Computer OR (n:User AND n.enabled=true))  AND (n.is_da IS NULL OR n.is_da=FALSE) AND (n.is_dc IS NULL OR n.is_dc=FALSE) WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p=shortestPath((n)-[:$properties$*1..$recursive_level$]->(m{target_kud:true})) WHERE NOT n=m AND (((n.is_da IS NULL OR n.is_da=FALSE) AND (n.is_dc IS NULL OR n.is_dc=FALSE)) OR (NOT m.domain CONTAINS '.' + n.domain AND n.domain <> m.domain)) RETURN DISTINCT(p)",
        "gds_request": "MATCH (target{target_kud:true}) CALL gds.allShortestPaths.dijkstra.stream('graph_kud', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE ((starting_node:Computer OR (starting_node:User AND starting_node.enabled=true))  AND (starting_node.is_da IS NULL OR starting_node.is_da=FALSE) AND (starting_node.is_dc IS NULL OR starting_node.is_dc=FALSE)) AND (target <> starting_node AND (((starting_node.is_da IS NULL OR starting_node.is_da=FALSE) AND (starting_node.is_dc IS NULL OR starting_node.is_dc=FALSE)) OR (NOT target.domain CONTAINS '.' + starting_node.domain AND starting_node.domain <> target.domain))) RETURN path as p",
        "reverse_path": true,
        "output_type": "Graph",
        "scope_query": "MATCH (n) WHERE (n:Computer OR (n:User AND n.enabled=true))  AND (n.is_da IS NULL OR n.is_da=FALSE) AND (n.is_dc IS NULL OR n.is_dc=FALSE) RETURN count(n)"
    },
    "nb_computers_laps": {
        "name": "Number of computers with laps",
        "request": "MATCH (c:Computer) WHERE NOT c.name is NULL and NOT c.haslaps IS NULL AND toUpper(c.operatingsystem) CONTAINS 'WINDOWS' RETURN DISTINCT(c.domain) AS domain, toInteger(($extract_date$ - c.lastlogontimestamp)/86400) as lastLogon, c.name AS name, toString(c.haslaps) AS LAPS",
        "output_type": "dict"
    },
    "can_read_laps": {
        "name": "Objects allowed to read LAPS",
        "request": "MATCH p = (n{path_candidate:true})-[r1:MemberOf*0..]->()-[r2:GenericAll|ReadLAPSPassword|AllExtendedRights|SyncLAPSPassword]->(t:Computer {haslaps:true}) RETURN distinct(n.domain) AS domain, n.name AS name",
        "output_type": "dict"
    },
    "objects_to_dcsync": {
        "name": "Objects to dcsync",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_objects_to_dcsync', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:$properties$]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_objects_to_dcsync', false) YIELD graphName",
        "request": "MATCH (n{path_candidate:true}) WHERE n.can_dcsync IS NULL AND NOT n.name IS NULL WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((n)-[r:$properties$*1..$recursive_level$]->(target{can_dcsync:TRUE})) WHERE n<>target RETURN distinct(p) AS p",
        "gds_request": "MATCH (target{can_dcsync:TRUE}) CALL gds.allShortestPaths.dijkstra.stream('graph_objects_to_dcsync', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE target <> starting_node AND starting_node.path_candidate = TRUE AND starting_node:User RETURN path as p",
        "output_type": "Graph",
        "scope_query": "MATCH (n{path_candidate:true}) WHERE n.can_dcsync IS NULL AND NOT n.name IS NULL RETURN count(n)",
        "reverse_path": true
    },
    "dom_admin_on_non_dc": {
        "name": "Domain admin with session on non DC computers",
        "request": "MATCH p=(c:Computer)-[r:HasSession]->(u:User{enabled:true, is_da:true}) WHERE NOT c.name IS NULL and NOT u.name IS NULL and NOT c.is_dc=True RETURN distinct(p) AS p",
        "output_type": "Graph"
    },
    "unpriv_to_dnsadmins": {
        "name": "Unprivileged users with path to DNSAdmins",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_unpriv_to_dnsadmins', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:MemberOf]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_unpriv_to_dnsadmins', false) YIELD graphName",
        "request": "MATCH (u:User{path_candidate:true}) WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 MATCH p=(u)-[r:MemberOf*1..$recursive_level$]->(g:Group{is_dnsadmin:true}) RETURN distinct(p) AS p",
        "gds_request": "MATCH (target:Group{is_dnsadmin:true}) CALL gds.allShortestPaths.dijkstra.stream('graph_unpriv_to_dnsadmins', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE target <> starting_node AND starting_node.path_candidate = TRUE AND starting_node:User RETURN path as p",
        "output_type": "Graph",
        "reverse_path": true,
        "scope_query": "MATCH (u:User{path_candidate:true}) RETURN count(u)"
    },
    "rdp_access": {
        "name": "Users with RDP-access to Computers ",
        "request": "MATCH (u:User{enabled:true,is_da:false}) WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 CALL {WITH u MATCH p=(u)-[r1:MemberOf*1..5]->(m:Group)-[r2:CanRDP]->(c:Computer) RETURN u.name as user, c.name as computer UNION ALL WITH u MATCH p=(u)-[r2:CanRDP]->(c:Computer) RETURN u.name as user, c.name as computer} RETURN DISTINCT user, computer",
        "scope_query": "MATCH (u:User{enabled:true,is_da:false}) RETURN count(u)",
        "output_type": "dict"
    },
    "dc_impersonation": {
        "name": "Non-domain admins that can directly or indirectly impersonate a Domain Controller ",
        "request": "MATCH (u{ou_candidate:true}) WITH u ORDER BY u.name SKIP PARAM1 LIMIT PARAM2 CALL{WITH u MATCH p=(u)-[r:MemberOf*1..5]->(g:Group)-[r3:AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl]->(m:Computer{is_dc:true}) RETURN p UNION ALL WITH u MATCH p=(u)-[r3:AddKeyCredentialLink|WriteProperty|GenericAll|GenericWrite|Owns|WriteDacl]->(m:Computer{is_dc:true}) RETURN p }RETURN DISTINCT p",
        "scope_query": "MATCH (u{ou_candidate:true}) RETURN count(u)",
        "output_type": "Graph"
    },
    "graph_rbcd": {
        "name": "Builds RBCD attack path graph and sets is_rbcd_target attribute ",
        "request": "MATCH (m:Computer{is_server:true}) WITH m SKIP PARAM1 LIMIT PARAM2 MATCH p=(u:User{path_candidate:true})-[rr:MemberOf|AddMember*0..5]->()-[r:GenericAll|GenericWrite|WriteDACL|AllExtendedRights|Owns]->(m) SET m.is_rbcd_target=TRUE RETURN p",
        "output_type": "Graph",
        "is_a_write_request": "true",
        "scope_query": "MATCH (m:Computer{is_server:true}) RETURN count(m)"
    },
    "graph_rbcd_to_da": {
        "name": "Builds RBCD targets to DA paths",
        "request": "MATCH (m:Computer{is_rbcd_target:true}) WHERE NOT m.name IS NULL WITH m ORDER BY m.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((m)-[r:$properties$*1..$recursive_level$]->(g:Group{is_dag:true})) WHERE m<>g RETURN DISTINCT(p) as p",
        "output_type": "Graph",
        "scope_query": "MATCH (m:Computer{is_rbcd_target:true}) WHERE NOT m.name IS NULL RETURN count(m)"
    },
    "compromise_paths_of_OUs": {
        "name": "Compromisable OUs",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_compromise_paths_of_OUs', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:MemberOf|GenericAll|GenericWrite|Owns|WriteOwner|WriteDacl|WriteGPLink]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_compromise_paths_of_OUs', false) YIELD graphName",
        "request": "MATCH (o:OU) WITH o ORDER BY ID(o) SKIP PARAM1 LIMIT PARAM2 MATCH p=shortestPath((u{ou_candidate:true})-[:MemberOf|GenericAll|GenericWrite|Owns|WriteOwner|WriteDacl|WriteGPLink*1..8]->(o:OU)) SET o.vulnerable_OU = TRUE RETURN p",
        "gds_request": "MATCH (target:OU) CALL gds.allShortestPaths.dijkstra.stream('graph_compromise_paths_of_OUs', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE starting_node.ou_candidate = TRUE SET starting_node.vulnerable_OU=true RETURN path as p",
        "output_type": "Graph",
        "reverse_path": true,
        "scope_query": "MATCH (o:OU) RETURN count(o)"
    },
    "vulnerable_OU_impact": {
        "name": "Impact of compromisable OUs",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_vulnerable_OU_impact', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:Contains|MemberOf]->(m) RETURN id(n) as source, id(m) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_vulnerable_OU_impact', false) YIELD graphName",
        "request": "MATCH (o:OU{vulnerable_OU:true}) WITH o ORDER BY o.name SKIP PARAM1 LIMIT PARAM2 MATCH p=shortestPath((o)-[:Contains|MemberOf*1..]->(e)) WHERE o <> e AND (e:User OR e:Computer) RETURN p",
        "gds_request": "MATCH (source:OU{vulnerable_OU:true}) CALL gds.allShortestPaths.dijkstra.stream('graph_vulnerable_OU_impact', {sourceNode: source, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS target_node, path WHERE target_node:User OR target_node:Computer RETURN path as p",
        "output_type": "Graph",
        "scope_query": "MATCH (o:OU{vulnerable_OU:true}) RETURN count(o)"
    },
    "vuln_functional_level": {
        "name": "Insufficient forest and domains functional levels. According to ANSSI (on a scale from 1 to 5, 5 being the better): the security level is at 1 if functional level (FL) <= Windows 2008 R2, at 3 if FL <= Windows 2012R2, at 4 if FL <= Windows 2016 / 2019 / 2022.",
        "request": "MATCH (o:Domain) WHERE NOT(o.functionallevel IS NULL OR SIZE(o.functionallevel) < 1) RETURN CASE WHEN toUpper(o.functionallevel) CONTAINS \"2000\" OR toUpper(o.functionallevel) CONTAINS \"2003\" OR toUpper(o.functionallevel) CONTAINS \"2008\" OR toUpper(o.functionallevel) CONTAINS \"2008 R2\" THEN 1 WHEN toUpper(o.functionallevel) CONTAINS \"2012\" THEN 2 WHEN toUpper(o.functionallevel) CONTAINS \"2016\" OR toUpper(o.functionallevel) CONTAINS \"2018\" OR toUpper(o.functionallevel) CONTAINS \"2020\" OR toUpper(o.functionallevel) CONTAINS \"2022\" THEN 5 END as `Level maturity`, o.distinguishedname as `Full name`, o.functionallevel as `Functional level`",
        "output_type": "dict"
    },
    "vuln_sidhistory_dangerous": {
        "name": "Accounts or groups with unexpected SID history",
        "request": "MATCH(o1)-[r:HasSIDHistory]->(o2{is_da:true}) RETURN o1.domain as parent_domain, o1.name as name, o1.sidhistory as sidhistory",
        "output_type": "dict"
    },
    "can_read_gmsapassword_of_adm": {
        "name": "Objects allowed to read the GMSA of objects with admincount=True",
        "request": "CALL {MATCH (o{path_candidate:true}) WITH o ORDER BY o.name SKIP PARAM1 LIMIT PARAM2 MATCH p=((o)-[:MemberOf*1..7]->(g:Group)-[:ReadGMSAPassword]->(u:User{is_admin:true})) WHERE o.name<>u.name RETURN DISTINCT(p) UNION ALL MATCH (o{path_candidate:true}) WITH o ORDER BY o.name SKIP PARAM1 LIMIT PARAM2 MATCH p=((o)-[:ReadGMSAPassword]->(u:User{is_admin:true})) WHERE o.name<>u.name RETURN DISTINCT(p) } RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (o{path_candidate:true}) RETURN count(o)"
    },
    "objects_to_operators_member": {
        "name": "Unprivileged users with path to an Operator Member",
        "request": "MATCH (m:User{path_candidate:true}) WITH m ORDER BY m.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((m)-[r:$path_to_group_operators_props$*1..$recursive_level$]->(o:User{is_operator_member:true})) WHERE m<>o AND ((o.is_da=true AND o.domain<>m.domain) OR (o.is_da=false)) RETURN DISTINCT(p) as p",
        "output_type": "Graph", 
        "scope_query": "MATCH (m:User{path_candidate:true}) RETURN count(m)",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_objects_to_operators_member', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:$path_to_group_operators_props$]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_objects_to_operators_member', false) YIELD graphName",
        "gds_request": "MATCH (target:User{is_operator_member:true}) CALL gds.allShortestPaths.dijkstra.stream('graph_objects_to_operators_member', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE starting_node:User AND target <> starting_node AND starting_node.path_candidate = TRUE AND ((target.is_da=true AND target.domain<>starting_node.domain) OR (target.is_da=false)) RETURN path as p",
        "reverse_path": true,
        "_comment": "TODO: table with type, account name, is_da (star) and the number of path towards it"
    },
    "objects_to_operators_groups": {
        "name": "Operator Member path to Operators Groups",
        "request": "MATCH (m:User{is_operator_member:true}) WITH m ORDER BY m.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((m)-[r:MemberOf*1..$recursive_level$]->(o:Group{is_group_operator:true})) WHERE (m.is_da=true AND o.domain<>m.domain) OR (m.is_da=false) RETURN DISTINCT(p) as p",
        "output_type": "Graph", 
        "scope_query": "MATCH (m:User{is_operator_member:true}) RETURN count(m)",
        "_comment": "TODO: table with type, account name, is_da (star) and the number of path towards it"
    },
    "vuln_permissions_adminsdholder": {
        "name": "Dangerous permissions on the adminSDHolder object",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_vuln_permissions_adminsdholder', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:$properties$]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_vuln_permissions_adminsdholder', false) YIELD graphName",
        "request": "MATCH (n:User{path_candidate:true}) WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((n)-[r:$properties$*1..4]->(target1{is_adminsdholder:true})) WHERE n<>target1 AND NOT ANY(no in nodes(p) WHERE (no.is_da=true AND (no.domain=target1.domain OR target1.domain CONTAINS \".\" + no.domain))) RETURN distinct(p) AS p",
        "gds_request": "MATCH (target{is_adminsdholder:true}) CALL gds.allShortestPaths.dijkstra.stream('graph_vuln_permissions_adminsdholder', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE starting_node:User AND target <> starting_node AND starting_node.path_candidate = TRUE AND NOT ANY(no in nodes(path) WHERE (no.is_da=true AND (no.domain=target.domain OR target.domain CONTAINS \".\" + no.domain))) RETURN path as p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:User{path_candidate:true}) RETURN count(n)",
        "reverse_path": true,
        "_comment": "TODO : table with les adminsdholder + path with => X objects to SDHolder"
    },
    "da_to_da": {
        "name": "Paths between two domain admins belonging to different domains",
        "request": "MATCH p=allShortestPaths((g:Group{is_dag:true})-[r:$properties$*1..$recursive_level$]->(gg:Group{is_dag:true})) WHERE g<>gg AND g.domain <> gg.domain RETURN p",
        "output_type": "Graph"
    },
    "anomaly_acl_1": {
        "name": "anomaly_acl_1",
        "request": "MATCH (gg) WHERE NOT gg:Group with gg as g MATCH (g)-[r2{isacl:true}]->(n) WHERE ((g.is_da IS NULL OR g.is_da=FALSE) AND (g.is_dc IS NULL OR g.is_dc=FALSE) AND (NOT g.is_adcs OR g.is_adcs IS NULL)) OR (NOT n.domain CONTAINS '.' + g.domain AND n.domain <> g.domain) RETURN n.name,g.name,type(r2),LABELS(g),labels(n),ID(n)",
        "output_type": "dict"
    },
    "anomaly_acl_2": {
        "name": "anomaly_acl_2",
        "request": "MATCH (gg:Group) WHERE gg.members_count IS NOT NULL with gg as g order by gg.members_count DESC MATCH (g)-[r2{isacl:true}]->(n) WHERE ((g.is_da IS NULL OR g.is_da=FALSE) AND (g.is_dcg IS NULL OR g.is_dcg=FALSE) AND (NOT g.is_adcs OR g.is_adcs IS NULL)) OR (NOT n.domain CONTAINS '.' + g.domain AND n.domain <> g.domain) RETURN g.members_count,n.name,g.name,type(r2),LABELS(g),labels(n),ID(n) order by g.members_count DESC",
        "output_type": "dict"
    },
    "get_empty_groups": {
        "name": "Returns empty groups",
        "request": "MATCH (g:Group) WHERE NOT EXISTS(()-[:MemberOf]->(g)) AND NOT g.distinguishedname CONTAINS 'CN=BUILTIN' RETURN g.name AS `Empty group`, COALESCE(g.distinguishedname, '-') AS `Full Reference`",
        "output_type": "dict"
    },
    "get_empty_ous": {
        "name": "Returns empty ous",
        "request": "MATCH (o:OU) WHERE NOT ()<-[:Contains]-(o) RETURN o.name AS `Empty Organizational Unit`, COALESCE(o.distinguishedname, '-') AS `Full Reference`",
        "output_type": "dict"
    },
    "has_sid_history": {
        "name": "Objects that have a SID History",
        "request": "MATCH (a)-[r:HasSIDHistory]->(b) RETURN a.name AS `Has SID History`, LABELS(a) AS `Type_a`, b.name AS `Target`, LABELS(b) AS `Type_b`",
        "output_type": "dict"
    },
    "unpriv_users_to_GPO_init": {
        "name": "Initialization request for GPOs [WARNING: If this query is too slow, you can use --gpo_low]",
        "request": "MATCH (n:User{path_candidate:true}) WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = shortestPath((n)-[r:MemberOf|AddSelf|WriteSPN|AddKeyCredentialLink|AddMember|AllExtendedRights|ForceChangePassword|GenericAll|GenericWrite|WriteDacl|WriteOwner|Owns*1..]->(g:GPO)) WHERE NOT n=g AND NOT g.name IS NULL RETURN p ",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_unpriv_users_to_GPO_init', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:MemberOf|AddSelf|WriteSPN|AddKeyCredentialLink|AddMember|AllExtendedRights|ForceChangePassword|GenericAll|GenericWrite|WriteDacl|WriteOwner|Owns]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_unpriv_users_to_GPO_init', false) YIELD graphName",
        "gds_request": "MATCH (target:GPO) CALL gds.allShortestPaths.dijkstra.stream('graph_unpriv_users_to_GPO_init', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE starting_node:User AND target <> starting_node AND starting_node.path_candidate = TRUE RETURN path as p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:User{path_candidate:true}) RETURN count(n)",
        "postProcessing": "Neo4j.setDangerousInboundOnGPOs",
        "reverse_path": true,
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO_user_enforced": {
        "name": "Compromisable GPOs to users (enforced)",
        "request": "MATCH (n:User{enabled:true}) WHERE n.name IS NOT NULL WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = (g:GPO{dangerous_inbound:true})-[r1:GPLink {enforced:true}]->(container2)-[r2:Contains*1..]->(n) RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:User{enabled:true}) WHERE n.name IS NOT NULL RETURN count(n)",
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO_user_not_enforced": {
        "name": "Compromisable GPOs to users (not enforced)",
        "request": "MATCH (n:User{enabled:true}) WHERE n.name IS NOT NULL WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p = (g:GPO{dangerous_inbound:true})-[r1:GPLink{enforced:false}]->(container1)-[r2:Contains*1..]->(n) WHERE NONE(x in NODES(p) WHERE x.blocksinheritance = true AND (x:OU)) RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:User{enabled:true}) WHERE n.name IS NOT NULL RETURN count(n)",
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO_computer_enforced": {
        "name": "Compromisable GPOs to computers (enforced)",
        "request": "MATCH (n:Computer) WITH n ORDER BY n.name WITH n SKIP PARAM1 LIMIT PARAM2 MATCH p = (g:GPO{dangerous_inbound:true})-[r1:GPLink {enforced:true}]->(container2)-[r2:Contains*1..]->(n) RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:Computer) RETURN count(n)",
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO_computer_not_enforced": {
        "name": "Compromisable GPOs to computers (not enforced)",
        "request": "MATCH (n:Computer) WITH n ORDER BY n.name WITH n SKIP PARAM1 LIMIT PARAM2 MATCH p = (g:GPO{dangerous_inbound:true})-[r1:GPLink{enforced:false}]->(container1)-[r2:Contains*1..]->(n) WHERE NONE(x in NODES(p) WHERE x.blocksinheritance = true AND (x:OU)) RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (n:Computer) RETURN count(n)",
        "_comment": "This is a request for the --gpo_low option"
    },
    "unpriv_users_to_GPO": {
        "name": "Non privileged users to GPO",
        "request": "MATCH (g:GPO) WITH g ORDER BY g.name SKIP PARAM1 LIMIT PARAM2 OPTIONAL MATCH (g)-[r1:GPLink {enforced:false}]->(container1) WITH g,container1 OPTIONAL MATCH (g)-[r2:GPLink {enforced:true}]->(container2) WITH g,container1,container2 OPTIONAL MATCH p = (g)-[r1:GPLink]->(container1)-[r2:Contains*1..8]->(n1:Computer) WHERE NONE(x in NODES(p) WHERE x.blocksinheritance = true AND (x:OU)) WITH g,p,container2,n1 OPTIONAL MATCH p2 = (g)-[r1:GPLink]->(container2)-[r2:Contains*1..8]->(n2:Computer) RETURN p",
        "output_type": "Graph",
        "scope_query": "MATCH (g:GPO) RETURN COUNT(g)",
        "_comment": "this is the normal version of the GPO request"
    },
    "cross_domain_local_admins":{
        "name": "Users that are local admins cross-domain",
        "request": "MATCH p=(u{enabled:true})-[r:MemberOf*0..4]->()-[rr:AdminTo]->(c:Computer) WHERE c.ghost_computer IS NULL AND u.domain <> c.domain AND NOT c.domain CONTAINS u.domain RETURN DISTINCT p",
        "output_type": "Graph"
    },
    "cross_domain_domain_admins":{
        "name": "Users that are domain admins cross-domain",
        "request": "MATCH p=(u{enabled:true})-[r:MemberOf*1..4]->(g:Group{is_da:true}) WHERE u.domain <> g.domain AND NOT g.domain CONTAINS u.domain return p",
        "output_type": "Graph"
    },
    "primaryGroupID_lower_than_1000": {
        "name": "User with PrimaryGroupID lower than 1000",
        "request": "MATCH (n) WHERE (n:Group OR n:User) AND toInteger(split(n.objectid, \"-\")[-1]) < 1000 AND (n.enabled = true or n:Group) return toInteger(split(n.objectid, \"-\")[-1]) as sid, n.name, n.domain, n.is_da",
        "output_type": "list"
    },
    "pre_windows_2000_compatible_access_group": {
        "name": "Pre-Windows 2000 Compatible Access contains unauthenticated users",
        "request": "MATCH (n:Group) WHERE n.name STARTS WITH \"PRE-WINDOWS 2000 COMPATIBLE ACCESS@\" MATCH (m)-[r:MemberOf]->(n) WHERE NOT m.objectid ENDS WITH \"-S-1-5-11\" return m.domain, m.name, m.objectid, labels(m) as type",
        "output_type": "list"
    },
    "guest_accounts": {
        "name": "Guest accounts enabled",
        "request": "MATCH (n:User) WHERE n.objectid ENDS WITH \"-501\" RETURN n.name, n.domain, n.enabled",
        "output_type": "list"
    },
    "unpriviledged_users_with_admincount": {
        "name": "Unpriviledged users with admincount=1",
        "request": "MATCH (u:User{enabled:true}) WHERE u.is_da=false AND u.admincount=true RETURN u.name, u.domain, u.da_type",
        "output_type": "list"
    },
    "get_fgpp": {
        "name": "FGPP applied to users directly or via groups",
        "request": "MATCH (u:User) WHERE u.fgpp_name IS NOT NULL RETURN u.fgpp_msds_psoappliesto, u.fgpp_name, u.fgpp_msds_minimumpasswordlength, u.fgpp_msds_minimumpasswordage, u.fgpp_msds_maximumpasswordage, u.fgpp_msds_passwordreversibleencryptionenabled, u.fgpp_msds_passwordhistorylength, u.fgpp_msds_passwordcomplexityenabled, u.fgpp_msds_lockoutduration, u.fgpp_msds_lockoutthreshold, u.fgpp_msds_lockoutobservationwindow",
        "output_type": "list"
    },
    "azure_set_gag": {
        "name": "Set gag=TRUE to Global admin group",
        "request": "MATCH (a:AZRole) WHERE a.name STARTS WITH 'GLOBAL ADMINISTRATOR@' SET a.is_gag=TRUE",
        "output_type": "list",
        "is_a_write_request": "true"
    },
    "azure_user": {
        "name": "Get Azure Users",
        "request":"MATCH (n:AZUser) RETURN n.name AS Name, n.tenantid AS `Tenant ID`, n.onpremisesyncenabled AS onpremisesynced, n.onpremisesecurityidentifier AS SID",
        "output_type": "dict"
    },
    "azure_admin": {
        "name": "Get Azure Admins",
        "request":"MATCH p =(n)-[r:AZGlobalAdmin*1..]->(m) RETURN n.name AS Name, n.tenantid AS `Tenant ID`",
        "output_type": "dict"
    },
    "azure_groups": {
        "name": "get Azure Groups",
        "request": "MATCH (n:AZGroup) RETURN n.tenantid AS `Tenant ID`, n.name AS Name, COALESCE(n.description, '-') AS Description ",
        "output_type": "dict"
    },
    "azure_vm": {
        "name": "get Azure VM",
        "request": "MATCH (n:AZVM) RETURN n.tenantid AS `Tenant ID`, n.name AS Name, n.operatingsystem AS os",
        "output_type": "dict"
    },
    "azure_apps": {
        "name": "get Azure Apps",
        "request": "MATCH (n:AZApp) WHERE n.name IS NOT NULL AND SIZE(n.name) > 1 RETURN n.tenantid AS `Tenant ID`, n.name AS Name",
        "output_type": "dict"
    },
    "azure_devices": {
        "name": "get Azure Devices",
        "request": "MATCH (n:AZDevice) RETURN n.tenantid AS `Tenant ID`, n.name AS Name, n.operatingsystem AS os",
        "output_type": "dict"
    },
    "azure_users_paths_high_target": {
        "name": "Find all Azure Users with a Path to High Value Targets ",
        "is_a_gds_request": "true",
        "create_gds_graph": "CALL gds.graph.project.cypher('graph_azure_users_paths_high_target', 'MATCH (n) RETURN id(n) AS id', 'MATCH (n)-[r:$properties$]->(m) RETURN id(m) as source, id(n) AS target, r.cost as cost', {validateRelationships: false})",
        "drop_gds_graph": "CALL gds.graph.drop('graph_azure_users_paths_high_target', false) YIELD graphName",
        "request": "MATCH (n:AZBase{is_priv:false}) WITH n ORDER BY n.name SKIP PARAM1 LIMIT PARAM2 MATCH p=shortestPath((n)-[r:$properties$*1..$recursive_level$]->(m:AZBase{is_priv:true})) WHERE m<>n RETURN p",
        "gds_request": "MATCH (target:AZBase{is_priv:true}) CALL gds.allShortestPaths.dijkstra.stream('graph_azure_users_paths_high_target', {sourceNode: target, relationshipWeightProperty: 'cost', logProgress: false}) YIELD path WITH nodes(path)[-1] AS starting_node, path WHERE starting_node.is_priv = FALSE AND starting_node:AZBase RETURN path as p",
        "reverse_path": true,
        "output_type": "Graph",
        "scope_query": "MATCH (n:AZBase{is_priv:false}) RETURN count(n)"
    },
    "azure_ms_graph_controllers": {
        "name": "Return all direct Controllers of MS Graph",
        "request":"MATCH p = (n)-[r:AZAddOwner|AZAddSecret|AZAppAdmin|AZCloudAppAdmin|AZMGAddOwner|AZMGAddSecret|AZOwns]->(g:AZServicePrincipal {appdisplayname: \"Microsoft Graph\"}) RETURN p",
        "output_type": "Graph"
    },
    "azure_aadconnect_users": {
        "name": "Return all Users and Azure Users possibly related to AADConnect",
        "request":"MATCH (u) WHERE (u:User OR u:AZUser) AND (u.name =~ '(?i)^MSOL_|.*AADConnect.*' OR u.userprincipalname =~ '(?i)^sync_.*') OPTIONAL MATCH (u)-[:HasSession]->(s:Session) RETURN u.name AS Name, s AS Session, u.tenantid AS `Tenant ID`",
        "output_type": "dict"
    },
    "azure_admin_on_prem": {
        "name": "Return all Azure admins that are also on premise admins",
        "request": "MATCH (u:User{is_da:true})-[:SyncedToEntraUser]->(a:AZUser)-[r:AZGlobalAdmin]->() RETURN u.name as Name",
        "output_type": "dict"
    },
    "azure_role_listing": {
        "name": "List of all Azure roles",
        "request":"MATCH (a:AZRole) return distinct a.name AS Name, a.description AS Description",
        "output_type": "dict"
    },
    "azure_role_paths": {
        "name": "Paths to the Azure roles",
        "request":"MATCH p=(a:AZUser)-[r:AZHasRole]->(x) return distinct p",
        "output_type": "Graph"
    },
    "azure_reset_passwd": {
        "name": "Azure accounts that can reset passwords",
        "request": "MATCH (m:AZBase) WITH m ORDER BY ID(m) SKIP PARAM1 LIMIT PARAM2 MATCH p=(n)-[r:AZResetPassword]->(m) return distinct p",
        "scope_query": "MATCH (n:AZBase) RETURN count(n)",
        "output_type": "Graph"
    },
    "azure_last_passwd_change": {
        "name": "Last password change on Azure and on premise",
        "request":"MATCH (u:User {enabled:TRUE}),(a:AZUser) WHERE a.onpremisesecurityidentifier = u.objectid RETURN DISTINCT(u.name) AS Name, toInteger(($extract_date$ - u.pwdlastset )/ 86400) AS `Last password set on premise`, toInteger(($extract_date$ - (datetime('1970-01-01T00:00:00').epochMillis + duration.inSeconds(datetime('1970-01-01T00:00:00'), a.pwdlastset).seconds)) / 86400) AS `Last password set on Azure`",
        "output_type": "dict"
    },
    "azure_dormant_accounts": {
        "name": "Azure dormant accounts",
        "request": "MATCH (a:AZUser)-[:SyncedToADUser]->(u:User{enabled:TRUE}) RETURN a.name AS Name, toInteger(($extract_date$ - u.lastlogontimestamp)/86400) AS lastlogon, toInteger(($extract_date$ - u.whencreated)/86400) AS whencreated",
        "output_type": "dict"
    },
    "azure_accounts_disabled_on_prem": {
        "name": "Azure accounts that are disabled on premise",
        "request": "MATCH (a:AZUser{enabled:TRUE})-[:SyncedToADUser]->(u:User{enabled:FALSE}) RETURN a.name AS `Azure name`, a.enabled AS `Enabled on Azure`, u.name AS `On premise name`, u.enabled AS `Enabled on premise` UNION MATCH (a:AZUser{enabled:FALSE})-[:SyncedToADUser]->(u:User{enabled:TRUE}) RETURN a.name AS `Azure name`, a.enabled AS `Enabled on Azure`, u.name AS `On premise name`, u.enabled AS `Enabled on premise`",
        "output_type": "dict"
    },
    "azure_accounts_not_found_on_prem": {
        "name": "Azure accounts that are synced but do not exist on premise",
        "request":"MATCH (azUser:AZUser{onpremisesyncenabled:true}) WHERE NOT EXISTS {MATCH (user:User) WHERE user.objectid = azUser.onpremisesecurityidentifier} return azUser.name AS Name",
        "output_type": "dict"
    },
    "azure_tenants": {
        "name": "Get all Azure tenants",
        "request": "MATCH (t:AZTenant) RETURN t.name AS Name, t.tenantid AS ID",
        "output_type": "dict"
    },
    "azure_ga_to_ga": {
        "name": "Paths between two global admins belonging to different tenants",
        "request": "MATCH p=allShortestPaths((g:AZRole{is_gag:TRUE})-[r:$properties$*1..$recursive_level$]->(gg:AZRole{is_gag:TRUE})) WHERE g<>gg AND g.tenantid <> gg.tenantid RETURN p",
        "output_type": "Graph"
    },
    "azure_cross_ga_da": {
        "name": "Paths between tenants admin and domain admins",
        "request": "MATCH p=allShortestPaths((g:AZRole{is_gag:TRUE})-[r:$properties$*1..$recursive_level$]->(gg:Group{is_dag:TRUE})) RETURN p UNION MATCH p=allShortestPaths((gg:Group{is_dag:TRUE})-[r:$properties$*1..$recursive_level$]->(g:AZRole{is_gag:TRUE})) RETURN p",
        "output_type": "Graph"
    }
}
